## 选择排序
> 从头到尾扫描序列，找出最小一个关键字，和第一个关键字交换，接着剩下的关键字重复此步骤，最后序列会变得有序

**示例代码**
```
void SelectSort(int arr[], int n)
{
    int k;

    for (int i = 0; i < n; i++)
    {
        k = i;
        //从i后面的序列中选择最小的和i交换
        for (int j = i + 1; j < n; j++)
        {
            if (arr[j] < arr[k])
            {
                k = j;
            }
        }

        // 执行交换
        if (i != k)
        {
            t = arr[k];
            arr[k] = arr[i];
            arr[i] = t;
        }
    }
}
```

## 堆排序

> 堆是一种**数据结构**，是一种**完全二叉树**，满足**任何一个非叶子结点的值都不大于或者小于其左右孩子的值**。

**大顶堆**：根结点值比左右儿子大

**小顶堆**：根结点值比左右儿子小

**排序思想**

代表堆的完全二叉树的根结点的值是最大或者最小的，因此将一个无序序列调整成一个堆，就是找出这个序列的最大(最小值)；

然后将找出的这个值交换到序列的最后或最前。通过这样的操作，有序序列就增加一个元素，无序序列减少一个元素，对新的无序序列继续上述操作，就可以实现排序。

**手工实现将序列调整成堆**


**大顶堆代码实现**
```
void Sift(int Arr[], int low, int high)
{
    // i是根节点, j是左儿子
    int i = low, j = 2 * i + 1;
    int t = Arr[i];
    while(j <= high)
    {
        // 右儿子更大
        if (Arr[j] < Arr[j + 1] && j < high)
        {
            ++j;
        }

        if(t < Arr[j])
        {
            // 将较大的儿子调整到根节点，之后往下移动
            Arr[i] = Arr[j];
            i = j;
            j = 2 * i + 1;
        }
        else
        {
            break;
        }
    }
    // 被调整的结点放入到最终位置
    R[i] = t;
}

void HeapSort(int Arr[], int n)
{
    int i;
    int t;
    // 建立初始堆
    for (i = n / 2; i >= 0; --i)
    {
        Sift(Arr, i, n);
    }

    for (i = n; i >= 1; i--)
    {
        // 将根节点的关键字放入到最后一个位置
        t = Arr[0];
        Arr[0] = Arr[i];
        Arr[i] = t;
        Sift(Arr, 0, i - 1);
    }
}
```