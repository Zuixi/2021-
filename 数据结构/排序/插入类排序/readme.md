## 直接插入排序

**排序过程叙述**

原始序列：**{49(a)，38，65，97，76，13，27, 49(b)}**

序列中有两个49，分别以a、b表示区别

1. 一开始只有49，肯定有序
> **49(a)**  | 38，65，97，76，13，27,49(b)

2. **插入38**， 38比49小，49向后移动一个位置
> **38 49(a)** | 65，97，76，13，27, 49(b)

3. **插入65**, 65比49大，不需要移动
> **38 49(a) 65** | 97，76，13，27, 49(b)

4. **插入97**, 97比65大，不需要移动
> **38 49(a) 65 97** | 76，13，27, 49(b)

5. **插入76**, 76比97小，97后移一个位置
> **38 49(a) 65 76  97** | 13，27, 49(b)

6. **插入13**, 13比38小，38后移一个位置
> **13 38 49(a) 65 76  97** | 27, 49(b)

7. **插入27**, 27比38小，38后移一个位置
> **13 27 38 49(a) 65 76  97** | 49(b)

7. **插入49（b)**, 49(b)比65小，65后移一个位置
> **13 27 38 49(a) 49(b) 65 76  97** 

**算法实现**
```
void InsertSort(int Array[], int n)
{
    int i, j;
    int temp;

    // 第一个元素肯定有序，从第二个元素开始插入
    for (i = 1; i < n; i++)
    {
        temp = Array[i];
        
        // 插入之前有序的序列
        j = i - 1;

        while( j >= 0 && temp < Array[j])
        {
            // 有序序列的值大于插入值，则一个个后移
            Array[j + 1] = Array[j];
            // 退出前j 会到插入位置的前一个元素
            j--;
        }
        Array[j + 1] = temp;
    }
}
```

**注意**
> 插入排序，**一趟排序之后并不能确保一个关键字到达其最终位置**

## 折半插入排序
> 折半插入排序的思想和直接插入排序是一样的，只是选择插入位置的方法不一样，使用了**二分的思想寻找插入位置**

**使用的基本条件**：序列基本有序

**例子**

原始序列：**13, 38, 49, 65, 76, 97** | 27, 49

插入关键字27，选择插入位置的过程如下所示:

1. low = 0; high = 5; m = 2, 2位置处的49 大于 27, **high  = m - 1**
2. low = 0, high = 1; m = 0, 0位置处的13小于 27, **low = m + 1**
3. low = 1, high = 1, m = 1, 1位置处的38大于27, **high = m - 1**
4. **high < low**, 退出循环，m就是插入位置

```
void BinaryInsertSort(int Array[], int n)
{
    int i, j;
    int temp;


    // 第一个元素肯定有序，从第二个元素开始插入
    for (i = 1; i < n; i++)
    {
        temp = Array[i];
        
        // 插入之前有序的序列
        j = i - 1;
        int low, mid, high;
        low = mid = 0;
        high = j;

        // 寻找插入位置
        while(low <= high)
        {
            mid = low + (high - low)/2;
            
            if (Array[mid] > temp)
                high = mid - 1;
            if (Array[mid] < temp)
                low = mid + 1;
        }

        // 移动位置元素固定的
        while( j >= mid)
        {
            // 有序序列的值大于插入值，则一个个后移
            Array[j + 1] = Array[j];
            j--;
        } 
        Array[mid] = temp;
    }
}
```


## 希尔排序
> **缩小增量排序**


**手工希尔排序的过程**